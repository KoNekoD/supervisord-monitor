#!/usr/bin/env php
<?php

declare(strict_types=1);

require_once __DIR__.'/../vendor/autoload.php';

use Composer\XdebugHandler\XdebugHandler;
use Riverwaysoft\PhpConverter\Ast\Converter;
use Riverwaysoft\PhpConverter\Ast\DtoVisitor;
use Riverwaysoft\PhpConverter\Ast\UsageCollector;
use Riverwaysoft\PhpConverter\Bridge\Symfony\SymfonyControllerVisitor;
use Riverwaysoft\PhpConverter\ClassFilter\PhpAttributeFilter;
use Riverwaysoft\PhpConverter\CodeProvider\FileSystemCodeProvider;
use Riverwaysoft\PhpConverter\Language\LanguageGeneratorInterface;
use Riverwaysoft\PhpConverter\Language\TypeScript\TypeScriptGenerator;
use Riverwaysoft\PhpConverter\Language\UnknownTypeResolver\ClassNameTypeResolver;
use Riverwaysoft\PhpConverter\Language\UnknownTypeResolver\DateTimeTypeResolver;
use Riverwaysoft\PhpConverter\OutputDiffCalculator\OutputDiffCalculator;
use Riverwaysoft\PhpConverter\OutputWriter\SingleFileOutputWriter\SingleFileOutputWriter;
use Symfony\Component\Console\Application;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Filesystem\Filesystem;
use Webmozart\Assert\Assert;

$application = new Application();

class ConvertCommand
    extends Command
{
    private UsageCollector $usageCollector;

    public function __construct(
        private readonly Converter $converter,
        private readonly LanguageGeneratorInterface $languageGenerator,
        private readonly Filesystem $fileSystem,
        private readonly OutputDiffCalculator $diffWriter,
        private readonly FileSystemCodeProvider $fsCodeProvider,
    ) {
        parent::__construct('php-converter-ts');
        $this->usageCollector = new UsageCollector();
    }

    protected function configure(): void
    {
        $this
            ->addOption(
                'from',
                'f',
                InputOption::VALUE_REQUIRED
            )
            ->addOption(
                'to',
                't',
                InputOption::VALUE_REQUIRED
            )
            ->addOption(
                'xdebug',
                'x',
                InputArgument::OPTIONAL,
                'Do not turn off Xdebug'
            )
            ->addOption(
                'branch',
                'b',
                InputOption::VALUE_OPTIONAL
            );
    }

    protected function execute(
        InputInterface $input,
        OutputInterface $output
    ): int {
        if (!$input->getOption('xdebug')) {
            $this->turnOffXdebug();
        }

        $from = $input->getOption('from');
        $to = $input->getOption('to');
        Assert::directory($to);

        $files = $this->fsCodeProvider->getListings($from);
        if (empty($files)) {
            $output->writeln('No files to convert');

            return Command::SUCCESS;
        }

        if ($output->isVerbose()) {
            $this->usageCollector->startMeasuring();
        }

        $converterResult = $this->converter->convert($files);
        $outputFiles = $this->languageGenerator->generate($converterResult);

        foreach ($outputFiles as $outputFile) {
            $outputAbsolutePath = sprintf(
                "%s/%s",
                rtrim($to, '/'),
                $outputFile->getRelativeName()
            );

            $newFileContent = $outputFile->getContent();
            if ($this->fileSystem->exists($outputAbsolutePath)) {
                $diff = $this->diffWriter->calculate(
                    file_get_contents($outputAbsolutePath),
                    $newFileContent
                );
                if (empty($diff)) {
                    $output->writeln(
                        sprintf(
                            "\nNo difference between the old generated file and the new one: %s",
                            $outputFile->getRelativeName()
                        )
                    );
                } else {
                    $output->writeln(
                        sprintf(
                            "\nSuccessfully written file: %s",
                            $outputFile->getRelativeName()
                        )
                    );
                    $output->write($diff);
                }

                $this->fileSystem->remove($outputAbsolutePath);
            } else {
                $output->writeln(
                    sprintf(
                        "\nSuccessfully created file %s",
                        $outputFile->getRelativeName()
                    )
                );
            }
            $this->fileSystem->touch($outputAbsolutePath);
            $this->fileSystem->appendToFile(
                $outputAbsolutePath,
                $newFileContent
            );
        }

        if ($output->isVerbose()) {
            $this->usageCollector->endMeasuring();
            $output->writeln(
                "\n\nScript usage: ".json_encode(
                    $this->usageCollector->report()
                )
            );
        }

        return Command::SUCCESS;
    }

    private function turnOffXdebug(): void
    {
        $xdebug = new XdebugHandler('phpConverter');
        $xdebug->setPersistent();
        $xdebug->check();
        unset($xdebug);
    }
}

$application->add(
    new ConvertCommand(
        new Converter([
            new DtoVisitor(new PhpAttributeFilter('Dto')),
            new SymfonyControllerVisitor('DtoEndpoint'),
        ]),
        new TypeScriptGenerator(
            new SingleFileOutputWriter('generated.ts'),
            [
                new DateTimeTypeResolver(),
                new ClassNameTypeResolver(),
            ],
        ),
        new Filesystem(),
        new OutputDiffCalculator(),
        new FileSystemCodeProvider('/\.php$/'),
    )
);

$application->run();
